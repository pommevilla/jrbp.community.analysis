---
title: "Bacteria only"
---
<script>
$(document).ready(function() {
  $items = $('div#TOC li');
  $items.each(function(idx) {
    num_ul = $(this).parentsUntil('#TOC').length;
    $(this).css({'text-indent': num_ul * 10, 'padding-left': 0});
  });

});
</script>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data Preparation

```{r, message = FALSE, warning = FALSE}
library(data.table, warn.conflicts = FALSE)
library(igraph, warn.conflicts = FALSE)
```

`taxa` is the look-up table for the OTUs.  `cooccurrence_data` contains pairwise Spearman correlation ranks for pairs of OTUs.

```{r read_data}
taxa <- data.table(read.delim("./data/bacteria/bacteria_classified_otus", 
                              sep = "", header = TRUE))

head(taxa)

cooccurrence_data <- data.table(read.table("./data/bacteria/bacteria_cooccurrence", 
                                           col.names = c("treatment", "OTU_1", "OTU_2", "rho", "p")))

head(cooccurrence_data)
```

We process `coocurrence_data` by removing OTU interactions non-significant $\rho$ values by filtering out those with a $p$-value less than $0.05$, then filtering out cyanobacteria and choloroplast data, as well as all observations from bird samples:

```{r complete_data}
cooccurrence_data <- cooccurrence_data[p <= 0.05, -5]      # Remove p-values from table
cooccurrence_data <- cooccurrence_data[order(treatment, OTU_1, OTU_2)]
remove <- taxa[which(taxa[[4]] %in% c("Cyanobacteria","Chloroplast")),]$OTU
taxa <- taxa[-c(remove),]
complete_data <- cooccurrence_data[-c(which(apply(cooccurrence_data, 1, function(x) any(remove %in% x)))),]

bird_data <- cooccurrence_data[treatment == "Bird", ]
complete_data <- cooccurrence_data[treatment != "Bird", ]
```

We then remove all edges that are $\textit{not}$ connected to the indicated OTUs of interest:

```{r trim_data}
otus_of_interest <- c("Acinetobacter", "Gluconobacter", "Neokomagataea", "erwinia", "Pantoea", "resenbergiella", "Asaia", "Lactobacillus", "Pseudomonas")
otus_of_interest <- taxa[which(apply(taxa, 1, function(x) any(otus_of_interest %in% x))),]$OTU
trimmed_data <- complete_data[which(apply(complete_data, 1, function(x) any(otus_of_interest %in% x))), ]
head(trimmed_data)
```

We seperate the coocurrence data into a positive and negative group.

```{r}
trimmed_positive_weights <- trimmed_data[trimmed_data[['rho']] > 0]
head(trimmed_positive_weights)
```

```{r}
trimmed_negative_weights <- trimmed_data[trimmed_data[['rho']] < 0]
head(trimmed_negative_weights)
```

We'll look at the positive and negative networks for each of the three treatments, as well as when all the treatments are combined together.

# Patristic Distance Matrix

```{r pda.1, message = FALSE, warning = FALSE}
library(ape, warn.conflicts = FALSE)
```

`bacteria_phylo_tree` is a guide tree returned by MAFFT for the bacterial sequences [(info)][mafft_rough_guide_tree].  We read it into a `phylo` object.

[mafft_rough_guide_tree]: https://mafft.cbrc.jp/alignment/software/treeout.html

```{r pda.2}
rough_tree <- read.tree("./data/bacteria/bacteria_phylo_tree")
```

We use `cophenetic.phylo` to generate the patristic distances between each OTU.  The patristic distance will be used as a measure of similarity as in the paper ["Phylogenetic relatedness predicts priority effects in nectar yeast communities"][phylo_dist_paper].

[phylo_dist_paper]: https://www.ncbi.nlm.nih.gov/pubmed/21775330
```{r pda.3}
pd_matrix <- cophenetic.phylo(rough_tree)
rownames(pd_matrix) <- sub("^[^_]*_", "", rownames(pd_matrix)) 
colnames(pd_matrix) <- sub("^[^_]*_", "", colnames(pd_matrix))
pd_matrix[1:5, 1:5]
```

# Trimmed Data

All the following analysis is performed on the trimmed data set.  Specifically, this analysis only examines interactions between *Acinetobacter, Gluconobacter, Neokomagataea, erwinia, Pantoea, resenbergiella, Asaia, Lactobacillus, Pseudomonas*

## Exposed Communities

### Positive weights 
We create a directed graph weighted by Spearman correlation for the Exposed treatment for those OTUs that are positively correlated to each other:  
```{r tep.1}
exposed_data_positive <- trimmed_positive_weights[treatment == "Exposed"]
exposed_data_positive <- exposed_data_positive[, -1]
gr_exposed_positive <- graph.data.frame(exposed_data_positive, directed = FALSE)
plot(gr_exposed_positive, vertex.size = 3,
     vertex.label = NA)
```

To determine communities, we use `cluster_fast_greedy`, which does greedy (local) optimization of the graph's modularity score.

```{r tep.2}
exposed_communities_greedy_positive <- cluster_fast_greedy(gr_exposed_positive, weights = E(gr_exposed_positive)$rho)
plot(exposed_communities_greedy_positive, gr_exposed_positive, 
     layout = layout.fruchterman.reingold(gr_exposed_positive),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
     )
```

The modularity of the community structure is:
```{r tep.3}
(tep.mod <- modularity(gr_exposed_positive, membership(exposed_communities_greedy_positive)))
```


### Negative Weights

We repeat the above process for the negatively correlated OTUs:

```{r ten.1}
exposed_data_negative <- trimmed_negative_weights[treatment == "Exposed"]
exposed_data_negative <- exposed_data_negative[, -1]
exposed_data_negative[[3]] <- abs(exposed_data_negative[[3]])
gr_exposed_negative <- graph.data.frame(exposed_data_negative, directed = FALSE)
plot(gr_exposed_negative, vertex.size = 3,
     vertex.label = NA)
```

```{r ten.2}
exposed_communities_greedy_negative <- cluster_fast_greedy(gr_exposed_negative, weights = E(gr_exposed_negative)$rho)
plot(exposed_communities_greedy_negative, gr_exposed_negative, 
     layout = layout.fruchterman.reingold(gr_exposed_negative),
     vertex.size = 2, vertex.label = NA)
```

The modularity of the community structure is:
```{r ten.3}
(ten.mod <- modularity(gr_exposed_negative, membership(exposed_communities_greedy_negative)))
```

## Caged Communities

### Positive weights 

```{r tcp.1, echo = FALSE}
caged_data_positive <- trimmed_positive_weights[treatment == "Caged"]
caged_data_positive <- caged_data_positive[, -1]
gr_caged_positive <- graph.data.frame(caged_data_positive, directed = FALSE)
caged_communities_greedy_positive <- cluster_fast_greedy(gr_caged_positive, weights = E(gr_caged_positive)$rho)
```

```{r tcp.2}
plot(caged_communities_greedy_positive, gr_caged_positive, 
     layout = layout.fruchterman.reingold(gr_caged_positive),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
      )
```

The modularity of the community structure is:
```{r tcp.3}
(tcp.mod <- modularity(gr_caged_positive, membership(caged_communities_greedy_positive)))
```

### Negative Weights

```{r tcn.1}
caged_data_negative <- trimmed_negative_weights[treatment == "Caged"]
caged_data_negative <- caged_data_negative[, -1]
caged_data_negative[[3]] <- abs(caged_data_negative[[3]])
gr_caged_negative <- graph.data.frame(caged_data_negative, directed = FALSE)
caged_communities_greedy_negative <- cluster_fast_greedy(gr_caged_negative, weights = E(gr_caged_negative)$rho)
plot(caged_communities_greedy_negative, gr_caged_negative, 
     layout = layout.fruchterman.reingold(gr_caged_negative),
     vertex.size = 2, 
     vertex.label = NA)
```

The modularity of the community structure is:
```{r tcn.2}
(tcn.mod <- modularity(gr_caged_negative, membership(caged_communities_greedy_negative)))
```


## Bagged Communities

### Positive weights 

```{r tbp.1}
bagged_data_positive <- trimmed_positive_weights[treatment == "Bagged"]
bagged_data_positive <- bagged_data_positive[, -1]
gr_bagged_positive <- graph.data.frame(bagged_data_positive, directed = FALSE)
bagged_communities_greedy_positive <- cluster_fast_greedy(gr_bagged_positive, weights = E(gr_bagged_positive)$rho)
plot(bagged_communities_greedy_positive, gr_bagged_positive, 
     layout = layout.fruchterman.reingold(gr_bagged_positive),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
)
```

The modularity score of the community structure is:

```{r tbp.2}
(tbp.mod <- modularity(gr_bagged_positive, membership(bagged_communities_greedy_positive)))
```


### Negative Weights

```{r tbn.1}
bagged_data_negative <- trimmed_negative_weights[treatment == "Bagged"]
bagged_data_negative <- bagged_data_negative[, -1]
bagged_data_negative[[3]] <- abs(bagged_data_negative[[3]])
gr_bagged_negative <- graph.data.frame(bagged_data_negative, directed = FALSE)
bagged_communities_greedy_negative <- cluster_fast_greedy(gr_bagged_negative, weights = E(gr_bagged_negative)$rho)
plot(bagged_communities_greedy_negative, gr_bagged_negative, 
     layout = layout.fruchterman.reingold(gr_bagged_negative),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA)
```

Modularity score:
```{r tbn.2}
(tbn.mod <- modularity(gr_bagged_negative, membership(bagged_communities_greedy_negative)))
```

## All Treatments

We will now look at all treatments together.  Note that data points from Bird samples have already been removed.

### Positive Weights


```{r tap.1, error = TRUE}
trimmed_all_positive <- trimmed_positive_weights[, -1]
gr_trimmed_all_positive <- graph.data.frame(trimmed_all_positive, directed = FALSE)
trimmed_all_positive_communities <- cluster_fast_greedy(gr_trimmed_all_positive, 
                                    weights = E(gr_trimmed_all_positive)$rho)
```

Because all the treatments are being combined into one graph, there can be multiple (parallel) edges between OTUs.  The clustering algorithm we have been using requires that there not be multiple edges between OTUs. We will collapse multiple edges by taking their mean - that is the mean correlation of the two OTUs across all treatments. (Are there potential problems with this collapsing rule?) 

```{r tap.2}
gr_trimmed_all_positive <- simplify(gr_trimmed_all_positive, 
                                    edge.attr.comb = "mean")
trimmed_all_positive_communities <- cluster_fast_greedy(gr_trimmed_all_positive, 
                                    weights = E(gr_trimmed_all_positive)$rho)
plot(trimmed_all_positive_communities, gr_trimmed_all_positive, 
     layout = layout.fruchterman.reingold(gr_trimmed_all_positive),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
)
```

What's interesting here is that the graph has a lot of "spokes," which hints at important OTUs. 

Modularity score:
```{r tap.3}
(tap.mod <- modularity(gr_trimmed_all_positive, membership(trimmed_all_positive_communities)))
```

### Negative Weights


```{r tan.1}
trimmed_all_negative <- trimmed_negative_weights[, -1]
trimmed_all_negative[[3]] <- abs(trimmed_all_negative[[3]])
gr_trimmed_all_negative <- graph.data.frame(trimmed_all_negative, directed = FALSE)
gr_trimmed_all_negative <- simplify(gr_trimmed_all_negative, 
                                    edge.attr.comb = "mean")
trimmed_all_negative_communities <- cluster_fast_greedy(gr_trimmed_all_negative, 
                                    weights = E(gr_trimmed_all_negative)$rho)
plot(trimmed_all_negative_communities, gr_trimmed_all_negative, 
     layout = layout.fruchterman.reingold(gr_trimmed_all_negative),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
)
```

Modularity score:
```{r tan.4}
(tan.mod <- modularity(gr_trimmed_all_negative, membership(trimmed_all_negative_communities)))
```

# Complete Data

We reproduce the above analysis on the complete data sat.  Again, we separate the data into positive and negative networks:

```{r cd.1}
complete_positive_weights <- complete_data[complete_data[['rho']] > 0]
head(complete_positive_weights)
```

```{r cd.2}
complete_negative_weights <- complete_data[complete_data[['rho']] < 0]
head(complete_negative_weights)
```


## Exposed Communities

### Positive Weights 
```{r cep.1}
complete_exposed_positive <- complete_positive_weights[treatment == "Exposed"]
complete_exposed_positive <- complete_exposed_positive[, -1]
gr_complete_exposed_positive <- graph.data.frame(complete_exposed_positive, directed = FALSE)
complete_exposed_positive_communities <- cluster_fast_greedy(gr_complete_exposed_positive, 
                                                           weights = E(gr_complete_exposed_positive)$rho)
plot(complete_exposed_positive_communities, gr_complete_exposed_positive, 
     layout = layout.fruchterman.reingold(gr_complete_exposed_positive),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
     )
```

Modularity:
```{r cep.2}
(cep.mod <- modularity(gr_complete_exposed_positive, membership(complete_exposed_positive_communities)))
```

### Negative Weights

```{r cen.1}
complete_exposed_negative <- complete_negative_weights[treatment == "Exposed"]
complete_exposed_negative <- complete_exposed_negative[, -1]
complete_exposed_negative[[3]] <- abs(complete_exposed_negative[[3]])
gr_complete_exposed_negative <- graph.data.frame(complete_exposed_negative, directed = FALSE)
complete_exposed_negative_communities <- cluster_fast_greedy(gr_complete_exposed_negative, 
                                                           weights = E(gr_complete_exposed_negative)$rho)
plot(complete_exposed_negative_communities, gr_complete_exposed_negative, 
     layout = layout.fruchterman.reingold(gr_complete_exposed_negative),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
     )
```

Modularity:
```{r cen.2}
(cen.mod <- modularity(gr_complete_exposed_negative, membership(complete_exposed_negative_communities)))
```


## Caged Communities

### Positive Weights 
```{r ccp.1}
complete_caged_positive <- complete_positive_weights[treatment == "Caged"]
complete_caged_positive <- complete_caged_positive[, -1]
gr_complete_caged_positive <- graph.data.frame(complete_caged_positive, directed = FALSE)
complete_caged_positive_communities <- cluster_fast_greedy(gr_complete_caged_positive, 
                                                           weights = E(gr_complete_caged_positive)$rho)
plot(complete_caged_positive_communities, gr_complete_caged_positive, 
     layout = layout.fruchterman.reingold(gr_complete_caged_positive),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
     )
```

Modularity:
```{r ccp.2}
(ccp.mod <- modularity(gr_complete_caged_positive, membership(complete_caged_positive_communities)))
```
### Negative Weights

```{r ccn.1}
complete_caged_negative <- complete_negative_weights[treatment == "Caged"]
complete_caged_negative <- complete_caged_negative[, -1]
complete_caged_negative[[3]] <- abs(complete_caged_negative[[3]])
gr_complete_caged_negative <- graph.data.frame(complete_caged_negative, directed = FALSE)
complete_caged_negative_communities <- cluster_fast_greedy(gr_complete_caged_negative, 
                                                           weights = E(gr_complete_caged_negative)$rho)
plot(complete_caged_negative_communities, gr_complete_caged_negative, 
     layout = layout.fruchterman.reingold(gr_complete_caged_negative),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
     )
```

Modularity:
```{r ccn.2}
(ccn.mod <- modularity(gr_complete_caged_negative, membership(complete_caged_negative_communities)))
```

## Bagged Communities

### Positive Weights 
```{r cbp.1}
complete_bagged_positive <- complete_positive_weights[treatment == "Bagged"]
complete_bagged_positive <- complete_bagged_positive[, -1]
gr_complete_bagged_positive <- graph.data.frame(complete_bagged_positive, directed = FALSE)
complete_bagged_positive_communities <- cluster_fast_greedy(gr_complete_bagged_positive, 
                                                           weights = E(gr_complete_bagged_positive)$rho)
plot(complete_bagged_positive_communities, gr_complete_bagged_positive, 
     layout = layout.fruchterman.reingold(gr_complete_bagged_positive),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
     )
```

Modularity:
```{r cbp.2}
(cbp.mod <- modularity(gr_complete_bagged_positive, membership(complete_bagged_positive_communities)))
```

### Negative Weights
```{r cbn.1}
complete_bagged_negative <- complete_negative_weights[treatment == "Bagged"]
complete_bagged_negative <- complete_bagged_negative[, -1]
complete_bagged_negative[[3]] <- abs(complete_bagged_negative[[3]])
gr_complete_bagged_negative <- graph.data.frame(complete_bagged_negative, directed = FALSE)
complete_bagged_negative_communities <- cluster_fast_greedy(gr_complete_bagged_negative, 
                                                           weights = E(gr_complete_bagged_negative)$rho)
plot(complete_bagged_negative_communities, gr_complete_bagged_negative, 
     layout = layout.fruchterman.reingold(gr_complete_bagged_negative),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
     )
```

Modularity:
```{r cbn.2}
(cbn.mod <- modularity(gr_complete_bagged_negative, membership(complete_bagged_negative_communities)))
```

## All Treatments

### Positive Weights


```{r cap.1}
complete_all_positive <- complete_positive_weights[, -1]
gr_complete_all_positive <- graph.data.frame(complete_all_positive, directed = FALSE)
gr_complete_all_positive <- simplify(gr_complete_all_positive, 
                                    edge.attr.comb = "mean")
complete_all_positive_communities <- cluster_fast_greedy(gr_complete_all_positive, 
                                    weights = E(gr_complete_all_positive)$rho)
plot(complete_all_positive_communities, gr_complete_all_positive, 
     layout = layout.fruchterman.reingold(gr_complete_all_positive),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
)
```

Modularity score:
```{r cap.2}
(cap.mod <- modularity(gr_complete_all_positive, membership(complete_all_positive_communities)))
```



### Negative Weights


```{r, can.1}
complete_all_negative <- complete_negative_weights[, -1]
complete_all_negative[[3]] <- abs(complete_all_negative[[3]])
gr_complete_all_negative <- graph.data.frame(complete_all_negative, directed = FALSE)
gr_complete_all_negative <- simplify(gr_complete_all_negative, 
                                    edge.attr.comb = "mean")
complete_all_negative_communities <- cluster_fast_greedy(gr_complete_all_negative, 
                                    weights = E(gr_complete_all_negative)$rho)
plot(complete_all_negative_communities, gr_complete_all_negative, 
     layout = layout.fruchterman.reingold(gr_complete_all_negative),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
)
```

Modularity score:
```{r can.2}
(can.mod <- modularity(gr_complete_all_negative, membership(complete_all_negative_communities)))
```


# Modularity

Collecting all modularity scores:

```{r mod.1}
treatments <- c("tep", "ten", "tcp", "tcn", "tbp", "tbn", "tap", "tan",
                        "cep", "cen", "ccp", "ccn", "cbp", "cbn", "cap", "can")
scores <- c(tep.mod, ten.mod, tcp.mod, tcn.mod, tbp.mod, tbn.mod, tap.mod, tan.mod,
            cep.mod, cen.mod, ccp.mod, ccn.mod, cbp.mod, cbn.mod, cap.mod, can.mod)
mod.scores <- data.table(treatments, scores)


library(ggplot2, warn.conflicts = FALSE)
ggplot(mod.scores, aes(x = "", y = scores)) + geom_boxplot() + 
    geom_jitter(shape = 16, aes(color = treatments))
```

# Birds

```{r bd.1}
bird_data <- bird_data[, -1]
otus_of_interest <- c("Acinetobacter", "Gluconobacter", "Neokomagataea", "erwinia", "Pantoea", "resenbergiella", "Asaia", "Lactobacillus", "Pseudomonas")
otus_of_interest <- taxa[which(apply(taxa, 1, function(x) any(otus_of_interest %in% x))),]$OTU
trimmed_bird <- bird_data[which(apply(complete_data, 1, function(x) any(otus_of_interest %in% x))),]
```

## Trimmed Data

### Positive Weights

```{r tbdp.1}
trimmed_bird_positive <- trimmed_bird[trimmed_bird[['rho']] > 0]
gr_trimmed_bird_positive <- graph.data.frame(trimmed_bird_positive, directed = FALSE)
gr_trimmed_bird_positive <- simplify(gr_trimmed_bird_positive, 
                                    edge.attr.comb = "mean")
trimmed_bird_positive_communities <- cluster_fast_greedy(gr_trimmed_bird_positive, 
                                    weights = E(gr_trimmed_bird_positive)$rho)
plot(trimmed_bird_positive_communities, gr_trimmed_bird_positive, 
     layout = layout.fruchterman.reingold(gr_trimmed_bird_positive),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
)

plot(trimmed_bird_positive_communities, gr_trimmed_bird_positive, 
     layout = layout.fruchterman.reingold(gr_trimmed_bird_positive),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label.cex = 1,
     vertex.label = ifelse(V(gr_trimmed_bird_positive)$name == "OTU_6", 
                           V(gr_trimmed_bird_positive)$name, "")
)
```


### Negative Weights


```{r tbdn.1}
trimmed_bird_negative <- trimmed_bird[trimmed_bird[['rho']] < 0]
trimmed_bird_negative[[3]] <- abs(trimmed_bird_negative[[3]])
gr_trimmed_bird_negative <- graph.data.frame(trimmed_bird_negative, directed = FALSE)
gr_trimmed_bird_negative <- simplify(gr_trimmed_bird_negative, 
                                    edge.attr.comb = "mean")
trimmed_bird_negative_communities <- cluster_fast_greedy(gr_trimmed_bird_negative, 
                                    weights = E(gr_trimmed_bird_negative)$rho)
plot(trimmed_bird_negative_communities, gr_trimmed_bird_negative, 
     layout = layout.fruchterman.reingold(gr_trimmed_bird_negative),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label.cex = 0.25
)
gr_trimmed_bird_negative
taxa[OTU %in% c("OTU_4898", "OTU_9")]
```

## Complete Data

### Positive Weights


```{r cbdp.1}
bird_positive <- bird_data[bird_data[['rho']] > 0]
gr_bird_positive <- graph.data.frame(bird_positive, directed = FALSE)
gr_bird_positive <- simplify(gr_bird_positive, 
                                    edge.attr.comb = "mean")
bird_positive_communities <- cluster_fast_greedy(gr_bird_positive, 
                                    weights = E(gr_bird_positive)$rho)
plot(bird_positive_communities, gr_bird_positive, 
     layout = layout.fruchterman.reingold(gr_bird_positive),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
)
```

### Negative Weights

```{r cbdn.1}
bird_negative <- bird_data[bird_data[['rho']] < 0]
bird_negative[[3]] <- abs(bird_negative[[3]])
gr_bird_negative <- graph.data.frame(bird_negative, directed = FALSE)
gr_bird_negative <- simplify(gr_bird_negative, 
                                    edge.attr.comb = "mean")
bird_negative_communities <- cluster_fast_greedy(gr_bird_negative, 
                                    weights = E(gr_bird_negative)$rho)
plot(bird_negative_communities, gr_bird_negative, 
     layout = layout.fruchterman.reingold(gr_bird_negative),
     rescaled = TRUE,
     vertex.size = 2, 
     vertex.label = NA
)
```